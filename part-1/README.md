# 3D Vector Class

You like video games? You like computer animation? Really enjoy movies with CGI and specifal effects?

All of these applications require the use of math. Thus far, we've learned that C++ has types to represent numbers (`int`, `float`, `double`) and there are operations to calculate sums (`+`), differences (`-`), products (`*`), quotients (`/`), and remainder (remember modulo `%`?). Can we write programs for computer graphics with these building blocks?

Yes of course. And our job would be a lot easier if we could teach our computer program more about [mathematics](https://en.wikipedia.org/wiki/Mathematics) and [physics](https://en.wikipedia.org/wiki/Physics). Specifically, if we could teach our program about [geometry](https://en.wikipedia.org/wiki/Geometry) then we could write programs about geometry rather than just numbers or strings.

Let's start by defining a basic element that we can use for computer graphics, physics, geometry, and all sorts of other exciting applications - a 3D [vector](https://en.wikipedia.org/wiki/Vector_(mathematics_and_physics)).


A 3D vector defines a direction in three-dimensional space. We can also think about a vector pointing at a [point](https://en.wikipedia.org/wiki/Point_(geometry)) in space. A vector can express which direction we are moving in and at what speed. A series of vectors can be used to desribe the edges of a [polygon](https://en.wikipedia.org/wiki/Polygon) or a path a robot moves along.

(Did you know a point isn't the samething as a vector? What operations are defined for vectors that are not defined for points?)

In this exercise, you are given a rudimentary 3D vector class named `Vec3`. The interface or description of the class is given in `vec3.h`. The inline documentation explains what the different parts of the class do and with your previous knowledge of how classes are defined you can use this as an example of how to create classes for future assignments.

Some of the member functions in `Vec3` have already been implemented. Other member functions need an implementation. Thankfully, a unit test program is provided to ensure that your implementations are behaving correctly.

The projects has the following files:
* `vec3.cc`
* `vec3.h` Do not edit this file.
* `vec3_unittest.cc` Do not edit this file.
* `vec_demo.cc` Do not edit this file.

Look for the `TODO` comments to help you identify where to focus your attention. If everything is implemented correctly then your project shall pass all unit tests and the program `vec_demo` will have output identical to what's shown in the README.

## Requirements

Review the C++ source files and identify all the TODOs. Implement each member function as specfied such that the main function in `vec_demo.cc` executes correctly and all unit tests (`make unittest`) are passed. Remember you can always check your application using `make test`.

You can verify the correctness of the main function by verifying the output against the sample output and by verifying the math by hand.

To compile your program, you use the `make` command. A Makefile is provided for this exercise.

The Makefile has the following targets:
  
* all: builds the project
* clean: removes object and dependency files
* spotless: removes everything the clean target removes and all binaries
* format: outputs a [`diff`](https://en.wikipedia.org/wiki/Diff) showing where your formatting differes from the [Google C++ style guide](https://google.github.io/styleguide/cppguide.html)
* lint: output of the [linter](https://en.wikipedia.org/wiki/Lint_(software)) to give you tips on how to improve your code
* header: check to make sure your files have the appropriate header
* test: run tests to help you verify your program is meeting the assignment's requirements. This does not grade your assignment.
* unittest: run unit tests to verify parts of your program performs according to the instructor supplied unit tests.
* doc: generate the project's documentation from the source files and store it in the directory named `doc`.

## Inline Documentation
The project is thoroughly documented inline using the [Doxygen](https://en.wikipedia.org/wiki/Doxygen) format. The documentation establishes a framework for you to follow so that you can implement all the details of the program. To generate HTML formatted documents to view on your computer use the make target `doc`.

The inline documentation is saved in `doc/html`. To view the documentation, use the command `gio open doc/html/index.html` which will open the index file in your web browser.

Another benefit of documenting your code is that when you use an editor like Visual Studio Code, it can show you the documentation when you point your mouse's cursor at a function name.


## Don't Forget

Please remember that:

- You need to put a header in every file.
- You need to follow the [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html).
- Remove the `TODO` comments.

## Testing Your Code

Computers only ever do exactly what they are told, exactly the way they are told it, and never anything else. Testing is an important process to writing a program. You need to test for the program to behave correctly and test that the program behaves incorrectly in a predictable way.

As programmers we have to remember that there are a lot of ways that we can write the wrong program and only one to a few ways to write the correct program. We have to be aware of [cognitive biases](https://en.wikipedia.org/wiki/List_of_cognitive_biases) that we may exercise that lead us to believe we have correctly completed our program. That belief may be incorrect and our software may have errors. [Errors in software](https://www.wired.com/2005/11/historys-worst-software-bugs/) may lead to loss of [life](https://www.nytimes.com/2019/03/14/business/boeing-737-software-update.html), [property](https://en.wikipedia.org/wiki/Mariner_1), [reputation](https://en.wikipedia.org/wiki/Pentium_FDIV_bug), or [all of the above](https://en.wikipedia.org/wiki/2009%E2%80%9311_Toyota_vehicle_recalls).

### Test strategy

Start simple, and work your way up. Good tests are specific, cover a broad range of fundamentally different possibilities, can identify issues quickly, easily, and directly, without need for much set up, and can almost be diagnosed by inspection if the code fails to execute the test correctly.

## Example Output

Please ensure your program's output is identical to the example below.

```
$ make unittest
set -e; clang++ -MM -g -O3 -Wall -pipe -std=c++14 -D LINUX -D AMD64 vec3.cc \
| sed 's/\(vec3\)\.o[ :]*/\1.o vec3.d : /g' > vec3.d; \
[ -s vec3.d ] || rm -f vec3.d
set -e; clang++ -MM -g -O3 -Wall -pipe -std=c++14 -D LINUX -D AMD64 vec_demo.cc \
| sed 's/\(vec_demo\)\.o[ :]*/\1.o vec_demo.d : /g' > vec_demo.d; \
[ -s vec_demo.d ] || rm -f vec_demo.d
rm: cannot remove 'unittest': No such file or directory
make: [Makefile:133: cleanunittest] Error 1 (ignored)
clang++ -g -O3 -Wall -pipe -std=c++14 -D LINUX -D AMD64 -c vec3.cc
Running main() from /build/googletest-j5yxiC/googletest-1.10.0/googletest/src/gtest_main.cc
[==========] Running 19 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 19 tests from Vec3Test
[ RUN      ] Vec3Test.GetX
[       OK ] Vec3Test.GetX (0 ms)
[ RUN      ] Vec3Test.GetY
[       OK ] Vec3Test.GetY (0 ms)
[ RUN      ] Vec3Test.GetZ
[       OK ] Vec3Test.GetZ (0 ms)
[ RUN      ] Vec3Test.UnaryMinus
[       OK ] Vec3Test.UnaryMinus (0 ms)
[ RUN      ] Vec3Test.Size
[       OK ] Vec3Test.Size (0 ms)
[ RUN      ] Vec3Test.SubscriptOperator
[       OK ] Vec3Test.SubscriptOperator (0 ms)
[ RUN      ] Vec3Test.Length
[       OK ] Vec3Test.Length (0 ms)
[ RUN      ] Vec3Test.LengthSquared
[       OK ] Vec3Test.LengthSquared (0 ms)
[ RUN      ] Vec3Test.PlusOperator
[       OK ] Vec3Test.PlusOperator (0 ms)
[ RUN      ] Vec3Test.MinusOperator
[       OK ] Vec3Test.MinusOperator (0 ms)
[ RUN      ] Vec3Test.MultiplicationOperator
[       OK ] Vec3Test.MultiplicationOperator (0 ms)
[ RUN      ] Vec3Test.DivisionOperator
[       OK ] Vec3Test.DivisionOperator (0 ms)
[ RUN      ] Vec3Test.Equality
[       OK ] Vec3Test.Equality (0 ms)
[ RUN      ] Vec3Test.Inequality
[       OK ] Vec3Test.Inequality (0 ms)
[ RUN      ] Vec3Test.Dot
[       OK ] Vec3Test.Dot (0 ms)
[ RUN      ] Vec3Test.Cross
[       OK ] Vec3Test.Cross (0 ms)
[ RUN      ] Vec3Test.UnitVector
[       OK ] Vec3Test.UnitVector (0 ms)
[ RUN      ] Vec3Test.Reflect
[       OK ] Vec3Test.Reflect (0 ms)
[ RUN      ] Vec3Test.StreamInsertionOperator
[       OK ] Vec3Test.StreamInsertionOperator (0 ms)
[----------] 19 tests from Vec3Test (1 ms total)

[----------] Global test environment tear-down
[==========] 19 tests from 1 test suite ran. (1 ms total)
[  PASSED  ] 19 tests.
$ make
clang++ -g -O3 -Wall -pipe -std=c++14 -D LINUX -D AMD64 -c vec_demo.cc
clang++ -g -O3 -Wall -pipe -std=c++14 -o vec_demo vec_demo.o vec3.o 
$ ./vec_demo 
zero == (0, 0, 0)
a == (1.1, 2.2, 3.3)
b == (3.1, 4.2, 5.3)
a + b == (4.2, 6.4, 8.6)
b - a == (2, 2, 2)
s == 3
b * s == (9.3, 12.6, 15.9)
s * b == (9.3, 12.6, 15.9)
a / s == (0.366667, 0.733333, 1.1)
Dot(a, zero) == 0
Dot(a, b) == 30.14
Cross(a, b) == (-2.2, 4.4, -2.2)
```

